# 虚拟机类加载机制

​	类被加载到虚拟机内存到卸载出内存，整个生命周期：

加载，验证，准备，解析，初始化，使用，卸载；7个阶段

验证准备解析统称 连接；

## 类加载时机

​	java虚拟机规范并没有严格规定加载时机，由具体的虚拟机实现决定

但是，对初始化有严格规定，有切仅有5种情况进行初始化。

1. 碰到new ,get static, putstatic, invokestatic 字节码指令的时候
2. 使用java.lang.reflect包的方法对类反射调用的时候
3. 初始化一个类，其父类没被初始化先初始化父类
4. 虚拟机启动时的主类
5. j d k1.7 动态语言支持时。。。

上面5个场景中的行为称为对一个类的**主动引用**

还有**被动引用**

> **被动引用场景**
>
> 1. 通过子类访问父类的静态属性，子类不会被初始化
> 2. new 一个类的数组
> 3. 访问一个类的 static final 修饰的属性，常量编译阶段进入常量池

## 类加载过程

​	加载全过程，**加载、验证、准备、解析、初始化。**

### 加载

----

1. 通过**类的全限定名**获取定义这个类的二进制流
2. 将二进制流转换为**方法区**的运行时数据结构
3. 在内存中生成一个代表这个类的java.long.Class对象，作为方法区这个类各种数据资源的访问入口

相比于其他的阶段 这个阶段 可控性最强，

加载阶段可以使用系统提供的 引导类加载器完成，也可以由用户自定义类加载器完成。

重写一个类加载器的loadClass()方法，自定义获取二进制流的方式。



### 验证

---

​	这个阶段的目的，确保class文件的字节流中包含的信息符合当前虚拟机的要求。

1. 文件格式检查

   魔数开头Cafebabe,版本号，常量池的常量类型，编码。。。。

2. 元数据验证

   语义分析，是否有父类Object,是否继承了final修饰的类。。。。

3. 字节码验证

   对类的方法体进行校验分析，符合逻辑，最复杂的阶段

4. 符号引用验证

   发生在虚拟机将符号引用转化为直接引用的时候，在 第三阶段连接中发生

   例如：符号引用中通过字符串描述的全限定名能否找到对应的类，

   ​			符号引用中的类、字段、方法，是否可以被当前类访问（private，protected, public,default）



### 准备

---

正式为类变量分配内存，设置类变量的初始值（静态变量），int = 0；





### 解析

---

​	虚拟机将常量池内的符号引用转化为直接引用的过程；

>  符号引用
>
> ​	用一组符号描述所引用的目标，符号任何形式的字面量，只要能定位目标即可。
>
> ​	引用的目标并不一定要加载到内存中。

> 直接引用
>
> ​	直接指向目标的指针，相对偏移量，或者能定位到目标的句柄。
>
> ​	直接引用的目标**必定已经在**内存中

解析动作主要针对

1. 类或者接口
2. 字段
3. 类方法
4. 接口方法
5. 方法类型
6. 方法句柄
7. 调用限定符

###  初始化

---

​	初始化阶段是加载过程的最后一个阶段，整个过程除了**加载阶段，可以用户自定义加载器**其他阶段都由虚拟机控制，**到了初始化阶段，才开始执行类中定义的程序代码。**

​	初始化阶段是执行，类构造器 clinit()方法的过程，**cli ni t() 特点：**

------

1. clinit() 方法，是由编译器自动收集类中，所有**类变量**（静态属性）的赋值动作，**静态语句块**中的语句合并生成的，执行顺序源码中的顺序一致。

2. clinit() 方法，和构造器init() 方法不同，不需要显示的调用父类的类构造器，由虚拟机保证父类先执行，**因为父类的clinit()方法先执行，所以父类的静态代码先执行**

	3. cli ni t() 方法不是必须的，没有变量，没有静态块就不生成
 	4. 接口的clinit() 方法，在接口中有变量赋值是才生成
 	5. 虚拟机保证一个类的clinit()方法在多线程环境下能被正常的加锁，同步。当一个线程执行clinit()方法时，其他**线程进入阻塞状态**。这里需要注意一个类的cli ni()方法不能消耗时间太长。

----





## 类加载器

​	通过类的全限定名，获取表述这个类的二进制字节流，实现这个动作的代码模块叫做类加载器。这个模块放在虚拟机外部完成，以便应用程序自己控制。

​	类加载器，应用领域：类层次划分、osgi、热部署、代码加密等。

### 类与类加载器

​	任何一个类，都需要由加载他的类加载器和这个类本身一同确立其在java 虚拟机中的唯一性。比较两个类是否相等，只有在同一类加载器加载的情况下才有意义。

​	相等是指，equals()方法、isAssignableFrom()方法、isInstance()、和Instanceof关键字。



### 双亲委派模型

​	从虚拟机的角度讲，分为两种不同的类加载器：

>  启动类加载器（bootstrap ClassLoad）,有c++实现是属于虚拟机的一部分。

>  其他类加载器都是java语言实现，独立于虚拟机外面。

​	从开发角度看，类加载器可以分为四种：

1. 启动类加载器（BootstrapClassLoad）

   ​	负责加载 <JAVA_HOME>/lib 目录中的或者-Xbootstrapclasspath参数指定的路径中的。并且是被虚拟机识别的（紧按照文件名识别，文件名不符合的不会加载）类库加载到虚拟机内存中。

   ​	无法被用户直接使用，如果需要委派给bootstrapClassLoad的话直接使用null代替

   ```java
   public ClassLoader getClassLoader(){
     ClassLoader cl = getClassLoader0();
     if (cl == null){
       return null;
     }
     ......
   }
   ```

   

2. 扩展类加载器（Extension ClassLoader)

   实现类：sun.misc.Launcher$ExtClassLoader

   负责加载<JAVA_HOME>/lib/ext目录中的或者，被java.ext.dirs系统变量制定的路径下的所有类库。

3. 应用程序类加载器（application ClassLoader) 

   实现类：sun.misc.Launcher$App-ClassLoader

   是ClassLoader 中的getSystemClassLoader()方法返回值，所以也叫系统类加载器，

   负责加载用户类路径（ClassPath）上所指定的类库。

   如果没有用户自定义的类加载器这是默认的类加载器。

**双亲委派模型的工作过程：**

​	类加载器收到类加载请求，首先把请求委派给父类加载器完成，每层都是如此。所以所有的加载请求最终都传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成加载请求，子类才会尝试自己加载。

**双亲委派的好处：**

	1. Java 类随着类加载器，具备了带有优先级的层次关系
 	2. 保证jdK 中类的安全型，不能自定义同名的类，定义了也不会加载



### 双亲委派模型破坏

出现过3次较大规模的破坏情况

- 第一次破坏

  发生在双亲委派模型出现之前，j d k1.2发布之前。j d k1.2之后才引入双亲委派模型

  **类加载器ß和抽象类ClassLoader在j d k1.0 时已经存在**，为了向前兼容，jdk1.2 版本加入了findClass()方法

  loadClass()方法完成双亲委派的逻辑，向上委派加载失败的情况下调用findClass()方法，这样依然符合双亲委派逻辑，所以提倡自定义加载器重写findClass方法。

- 第二次破坏

  所有设计SPI的加载动作，JNDI,JDBC,JCE,JAXB,JBI

  以JNDI为例：

  JNDI 的接口 在JDK1.3 时被放在了tr.jar. 中，由顶层类加载器加载，而SPI的代码在ClassPath下，所以顶层类加载器不可能加载到这些代码。

  为了解决这个问题，引入了线程上下文类加载器（Thread Context ClassLoader) ，通过java.lang.Thread类的setContextClassLoader()方法进行设置，没有设置的话从父线程中继承一个，所以默认时App-ClassLoader

  JNDI服务用这个类加载器加载SPI的代码，这样就顶层类加载器调用子类加载器完成了类加载，这样就破坏了双亲委派模型。

- 第三次破坏

  代码热替换，程序热部署OSGi

  OSGI通过替换类加载器实现代码的热替换。

  不再是双亲委派模型，而是网状模型